# design-loop: Webデザイン以外のユースケース探索

## 核となる抽象化

design-loopの本質は「Webサイトデザインツール」ではなく、**ビジュアルフィードバックループ付きのAIエディタ**。

```
プレビュー → 指し示す → 自然言語で指示 → ソース編集 → ライブ更新
```

このループは「ブラウザで表示でき、編集可能なソースファイルがある」ものなら何にでも適用できる。

## 現在のアーキテクチャの前提

現状は以下を前提としている:

1. **プレビュー元**: ローカルdev server（localhost:3000等）がHTMLを返す
2. **プロキシ**: HTTPレスポンスを傍受してスクリプトを注入
3. **要素選択**: DOM要素 + React Fiber → コンポーネント情報
4. **編集対象**: ソースコード（TSX/CSS）
5. **更新**: HMR（Hot Module Replacement）

ユースケースを広げるには、これらの前提のどれを緩和・一般化するかがポイントになる。

---

## ユースケース一覧

### カテゴリA: そのまま動くもの（dev serverがHTMLを返す）

現在のアーキテクチャをほぼそのまま活用できる。

#### 1. Markdownプレビュー + 編集

- **プレビュー**: Markdownプレビューサーバ（VitePress, Docusaurus, mkdocs等）
- **フロー**: 記事をプレビュー → 段落や見出しをクリック → 「もっと簡潔に書き直して」「コード例を追加して」
- **編集対象**: `.md` ファイル
- **必要な変更**: 要素選択スクリプトでReact Fiberの代わりにMarkdownのソース行マッピングを取得。多くのMarkdownレンダラは `data-source-line` 等の属性を付与するので、それを利用可能
- **価値**: テクニカルライターがドキュメントを書く際のフローが改善。プレビューを見ながら「ここの説明がわかりにくい」と指せる

#### 2. スライド/プレゼンテーション

- **プレビュー**: reveal.js, Marp, Slidev等のプレゼンツール
- **フロー**: スライドをプレビュー → テキストや図をクリック → 「フォントを大きくして」「箇条書きを3つに減らして」
- **編集対象**: Markdown（Marp/Slidev）またはHTML（reveal.js）
- **必要な変更**: スライドナビゲーション（前/次のスライド）のサポート。要素選択でスライド番号のコンテキストを付与
- **価値**: プレゼン資料の微調整を自然言語で。特にMarpはMarkdownベースなので相性が良い

#### 3. メールテンプレートデザイン

- **プレビュー**: MJML, React Email等のメールテンプレートdev server
- **フロー**: メールをプレビュー → ボタンやテキストをクリック → 「CTAボタンの色を変えて」「ヘッダー画像を大きくして」
- **編集対象**: MJML/JSXファイル
- **必要な変更**: ほぼ不要。React Emailの場合はReact Fiberがそのまま使える
- **価値**: メールテンプレートの調整はCSSの制約が多く、AIの支援が特に有効

#### 4. コンポーネントライブラリ（Storybook）

- **プレビュー**: Storybook dev server
- **フロー**: コンポーネントをブラウズ → バリアントを選択 → 「ホバー時のアニメーションを追加して」「ダークモード対応にして」
- **編集対象**: コンポーネントファイル + Stories
- **必要な変更**: Storybookのiframe-in-iframe構造への対応
- **価値**: コンポーネントの見た目調整に特化したUX

#### 5. 静的サイト/ブログのコンテンツ編集

- **プレビュー**: Hugo, Astro, 11ty等のSSG dev server
- **フロー**: ブログ記事をプレビュー → 文章をクリック → 「この段落を短くして」「画像のキャプションを追加して」
- **編集対象**: Markdown/MDXファイル
- **必要な変更**: Markdown同様、ソース行マッピングの取得
- **価値**: コンテンツ編集者がプレビューを見ながら修正指示を出せる

---

### カテゴリB: プレビュー層の追加が必要なもの

dev serverが存在しないため、design-loop側でプレビュー機能を提供する必要がある。

#### 6. PDF生成ドキュメント（LaTeX / Typst）

- **プレビュー**:
  - 方式1: Typst/LaTeXをPDFにコンパイル → pdf.jsで表示
  - 方式2: Typstのウォッチモードが生成するPDFを自動リロード
- **フロー**: PDFをプレビュー → ページ/段落を指す → 「この数式のフォントサイズを大きくして」「余白を狭くして」
- **編集対象**: `.tex` / `.typ` ファイル
- **必要な変更**:
  - PDFプレビューアの組み込み（pdf.js）
  - ファイル変更監視 → 再コンパイル → プレビュー自動更新のパイプライン
  - PDF上の位置とソースファイルの行の対応付け（SyncTeX / Typstのソースマップ）
- **価値**: 論文やレポートの体裁調整。LaTeXの呪文を覚えなくても「ここの余白を詰めて」で済む
- **課題**: コンパイル時間がHMRと比べて長い。Typstは高速だがLaTeXは数秒かかる

#### 7. SVG / ダイアグラム編集

- **プレビュー**: SVGをiframeで直接表示、またはMermaid/D2等のダイアグラムをレンダリング
- **フロー**: ダイアグラムをプレビュー → ノードや矢印をクリック → 「この矢印を破線にして」「ノードの色を青にして」
- **編集対象**: `.svg` / `.mermaid` / `.d2` ファイル
- **必要な変更**:
  - SVG要素の選択（DOM要素としてそのまま使える）
  - Mermaid/D2のファイル監視 → 再レンダリング
- **価値**: ダイアグラムの微調整は手作業が面倒。テキストベースの図表記法 + AIで効率化

#### 8. データ可視化 / チャート

- **プレビュー**: Observable / D3 / Chart.js等のチャートをHTMLで表示
- **フロー**: チャートをプレビュー → 軸やラベルをクリック → 「Y軸の範囲を0-100にして」「凡例を右に移動して」
- **編集対象**: チャート設定ファイル / Jupyter Notebook / Observableノートブック
- **必要な変更**: チャートライブラリ固有の要素選択（SVGベースならDOM選択で対応可能）
- **価値**: データサイエンティストがチャートの見た目を調整する際の反復が速くなる

---

### カテゴリC: プレビューのパラダイムが異なるもの

iframeでのHTML表示という枠組みを超えた対応が必要。

#### 9. ターミナルUI / CLIのデザイン

- **プレビュー**: ターミナル出力のスクリーンショットやANSIレンダリング
- **フロー**: CLIの出力を表示 → 「テーブルの罫線をUnicode文字にして」「エラーメッセージを赤にして」
- **編集対象**: CLI出力のフォーマットコード
- **課題**: ターミナル出力をブラウザでプレビューする標準的な方法がない

#### 10. モバイルアプリUI（React Native / Flutter）

- **プレビュー**: Expoのウェブプレビュー / Flutter Web
- **フロー**: アプリUIをプレビュー → ボタンや画面をクリック → 「このリストのスクロールを滑らかに」
- **編集対象**: TSX（React Native）/ Dart（Flutter）
- **課題**: Web版のプレビューとネイティブの見た目に差がある

---

## アーキテクチャへの示唆

### 一般化すべきポイント

現在のアーキテクチャをユースケースに応じて抽象化するなら、以下のレイヤーに分けられる:

```
┌──────────────────────────────────────────────┐
│              design-loop Core                 │
│  ┌────────────┐  ┌────────────┐  ┌─────────┐ │
│  │  Preview    │  │  Selector  │  │ Context │ │
│  │  Adapter    │  │  Adapter   │  │ Builder │ │
│  └────────────┘  └────────────┘  └─────────┘ │
│        ↓               ↓              ↓       │
│  ┌────────────────────────────────────────┐   │
│  │         PTY + Claude Code              │   │
│  └────────────────────────────────────────┘   │
└──────────────────────────────────────────────┘
```

1. **Preview Adapter**: コンテンツをブラウザに表示する方法
   - `proxy`: 既存dev serverをプロキシ（現在の方式）
   - `static`: 静的ファイルを直接サーブ（SVG, HTML）
   - `compile`: ソースをコンパイルしてプレビュー（LaTeX → PDF）
   - `render`: テキストをブラウザ内でレンダリング（Mermaid → SVG）

2. **Selector Adapter**: プレビュー内の要素を選択・情報取得する方法
   - `react-fiber`: React Fiberからコンポーネント情報（現在の方式）
   - `dom-generic`: DOM要素 + CSS selector のみ
   - `source-map`: ソース行マッピング（Markdown, Typst）
   - `pdf-region`: PDF上の領域選択（ページ番号 + 座標）

3. **Context Builder**: 選択情報をClaudeへのプロンプトに変換する方法
   - フレームワーク固有のコンテキスト（React Component, Panda CSS tokens等）
   - ファイルタイプ固有のコンテキスト（LaTeXコマンド, Mermaid構文等）

### `.design-loop.json` の拡張案

```jsonc
{
  // 現在の設定（Webデザイン用）
  "devServer": {
    "command": "pnpm run dev",
    "url": "http://localhost:3000"
  },

  // 新: プレビューモード
  "preview": {
    // "proxy" | "static" | "compile" | "render"
    "mode": "compile",

    // compile モードの場合
    "compile": {
      "command": "typst compile main.typ main.pdf",
      "watch": "typst watch main.typ main.pdf",
      "output": "main.pdf",
      "viewer": "pdf"  // "pdf" | "html" | "image"
    }
  },

  // 新: 要素選択の方式
  "elementSelection": {
    // "react-fiber" | "dom" | "source-map" | "pdf-region"
    "adapter": "source-map",
    "sourceMapAttribute": "data-source-line"
  }
}
```

---

## 優先度の提案

実装コストと価値のバランスから:

| 優先度 | ユースケース | 理由 |
|--------|------------|------|
| **高** | Markdownプレビュー | 変更最小。多くのdev serverがそのまま使える。ユーザー層が広い |
| **高** | スライド（Marp/Slidev） | Markdownと同じ仕組みで対応可能。ニーズが明確 |
| **中** | PDF（Typst） | 新しいプレビュー層が必要だが、Typstのコンパイルが高速で体験が良い |
| **中** | SVG/ダイアグラム | SVGはDOMなので要素選択がそのまま使える |
| **低** | メールテンプレート | ニッチだが、React Emailならほぼ変更なしで動く |
| **低** | データ可視化 | チャートライブラリごとの対応が必要 |

## 次のステップ

1. Markdownプレビュー（VitePress or Docusaurus）で動作確認 → 最小限の変更で動くか検証
2. Preview Adapterの抽象化を設計 → `proxy` 以外の `static` / `compile` モードの追加
3. Selector Adapterの抽象化 → React Fiber以外の要素選択方式
